[general]
# Working directory
PROJECT_DIR= /path/to/10x_to_10x_random/

# Path to the shellscript template.
# Lines used in all the shell scripts generated by INTERSTELLAR, 
# such as shebang and conda activate should be included.
SET_SHELL_ENV= /path/to/set_shell_env

# SAMPLESHEET specifies the correspondence between the FASTQ file prefixes
# and their samplename (tab-separated).
#
# Example:
# heart_10k_v3_S1_L001	10X
# heart_10k_v3_S1_L002	10X
# 
# This means it gives two FASTQ files from a single sample sequenced by two lanes
SAMPLESHEET=/path/to/samplesheet


[value_extraction]
# Path to input FASTQ files. FASTQ file names must include the fleprefixes indicated in SAMPLESHEET.
# 
# Example:
# READ1_PATH=/path/to/Input_dir/R1/*.fastq.gz
# READ2_PATH=/path/to/Input_dir/R2/*.fastq.gz
# 
# Alternatively, user can provide a directory path containing FASTQ files.
# READ1_PATH=/path/to/Input_dir/R1/
# READ2_PATH=/path/to/Input_dir/R2/
READ1_PATH=/path/to/R1
READ2_PATH=/path/to/R2


# Read structures specified by regular expression.
# Variables specified by ?P<> are user-defined sequence segments. INTERSTELLAR adopts the extended 
# regular expression implemented in the regex library (https://pypi.org/project/regex/) that allows mismatches.
READ1_STRUCTURE=^(?P<raw_cb>.{16})(?P<raw_umi>.{12})$
READ2_STRUCTURE=^(?P<raw_bio>.*)$

# Parental-local variable allocations.
# Under this allocation, sequence-to-value conversion of the local segment(s) is independently performed for its parental segment. 
# For example, cell IDs and UMIs of typical scRNA-seq reads can be defined as parental segments and their local segments, respectively,
# where the same UMI sequences associated with different cell IDs are interpreted as different objects. 
#
# Ex. 1) seg1 is a local variable of seg2:
# seg1 = CHILD_OF(seg2)
# 
# Ex. 2) seg2 and seg3 together consist of a combinatorial variable where seg1 is local to them:
# seg1 = CHILD_OF(seg2,seg3)
#
# Ex. 3) a combinatorial variable (seg1, seg2) is local to another combinatorial variable (seg3, seg4):
# seg1,seg2 = CHILD_OF(seg3,seg4)
raw_umi=CHILD_OF(raw_cb)

# Sequence filtering and correction for each segment
#
# - QUALITY_FILTER()
#   Filter segment sequences according to their Q scores with the following arguments:
#   * source (required)
#     Sequence segment variable name.
#  
#   * min_nucleotide_Q-score
#     Minimum per-base Q score threshold. Default=5.
# 
#   * min_avg_Q-score
#     Minimum average Q score threshold. Default=20.
#
# - I2M_CORRECTION()
#   Error-correct segment sequences by "imputation-to-majority."
#   * source
#     Sequence segment variable name. Not required If defined upstream and inherited by ">>"(see below).
#
#   * rank
#     Rank threshold for the minority-majority boundary of the rank-count plot of unique segment sequences. 
#     If this is set to "auto," the knee-point of the rank-count plot is adopted. Default=auto.
#
#   * levenshtein_distance
#     Maximum Levenshtein distance threshold allowed to correct sequences in the minority group to their 
#     nearest sequences in the majority group. Default=1.
#
# - M2A_CORRECTION()
#   Error-correct segment sequences by “mapping-to-allowlist.”
#
#   * source
#     Sequence segment variable name. Not required if defined upstream and inherited by “>>” (see below).
#
#   * path (required)
#     Path to the sequence allowlist.
#
#   * levenshtein_distance
#     Maximum Levenshtein distance threshold allowed to correct the input sequences to their nearest sequences 
#     in the allowlist. Default=1.
#
# - BARTENDER_CORRECTION()
#   Error-correct segment sequences using Bartender (URL). Please see Bartender’s manual for details.
#
#   * source
#     Sequence segment variable name. Not required if defined upstream and inherited by “>>” (see below).
#
#   * -c
#     Sequence frequency cutoff.
#
#   * -d
#     Maximum cluster distance that may be merged.
#
#   * -z
#     Cluster merging threshold.
#
#   * -l
#     Seed length.
#
#   * -s
#     Number of non-overlapping positions between two adjacent seeds.
#
# - CUSTOM_CORRECTION()
#   Error-correct segment sequences using a user-provided shell script.
#
#   * source
#     Sequence segment variable name. Not required if defined upstream and inherited by “>>” (see below).
#
#   * shell_script
#     Path to the shell script.
#     The script must be designed to accept an input sequence segment list in a TSV (tab-separated value) file format 
#     as the first argument $1 and output the conversion result in STDOUT in a TSV format at the second argument $2 of the shell script.
#
# - SEQ2VALUE()
#   Convert segment sequences into (unoptimized) segment values. This process is required if the segment sequences are supposed 
#   to be translated into different sequences.
#   * source
#     source Sequence segment variable name. Not required if defined upstream and inherited by “>>” (see below).
#
# - Pipe-like operator
#   “>>” can be used as a pipe-like operator, connecting multiple processes in one line.

segment1.filtered.corrected.value =QUALITY_FILTER(source:raw_cb, min_nucleotide_Q-score:5, min_avg_Q-score:20) >> M2A_CORRECTION(levenshtein_distance:1,path:/path/to/10x_3M-february-2018.txt) >>  SEQ2VALUE()
segment3.filtered.value =QUALITY_FILTER(source:raw_umi, min_nucleotide_Q-score:5, min_avg_Q-score:20) >>  SEQ2VALUE()
segment5.filtered=QUALITY_FILTER(source:raw_bio, min_nucleotide_Q-score:5, min_avg_Q-score:20)


[value_translation]
# Defining destination segment sequences
# The destination sequence segments can be defined by VALUE2SEQ() or SEQ2SEQ(), or by directly assigning source sequence segments.
# The following functions can be used for producing defining sequence segments.
#
# - VALUE2SEQ()
#   Assign destination segment sequences to values so they fit to an allowlist or destination sequence segment structure. 
#   In this section, value space optimization is automatically performed for source segment values according to the segment grouping rules and 
#   parental-local segment value allocations defined in the value_extraction section. 
#   The value space optimization is not performed if any parental-local segment value allocation is defined earlier.
#
#   * source (required)
#     Value names. Comma-separated values if multiple values are translated into a sequence segment. Note that the source segment combinations used in
#
#   * allowlist_path
#     Path to the destination sequence allowlist. If multiple destination sequence segments are to be generated, provide their corresponding allowlists 
#     as comma-separated values in the same order of destination sequence segments.
#
#   * randseq_pattern
#     Destination sequence segment structure defined by IUPAC codes. If multiple destination sequence segments are to be defined, provide their corresponding 
#     allowlists as comma-separated values in the same order of destination sequence segments.
#
# - SEQ2SEQ() 
#   Assign destination segment sequences defined for their corresponding source segment sequences according to a user-defined sequence conversion table.
#
#   * source (required):
#     Source sequence segment name. Comma-separated values if multiple source segments are converted into a destination sequence(s).
#
#   * conversion_table
#     Path to the sequence conversion table (TSV file format). The header line must correspond to the target source and destination sequence segment names 
#     defined in the configuration file. Each SEQ2SEQ function requires a unique sequence conversion table.
#
# Bequeathing a source segment Source sequence segment variables can be used to define destination reads.

dest_segment1=VALUE2SEQ(source:segment1.filtered.corrected.value, allowlist_path:/path/to/10x_3M-february-2018.txt)
dest_segment2=VALUE2SEQ(source:segment3.filtered.value, randseq_pattern:NNNNNNNNNNNN)
dest_segment3=segment5.filtered

# Read structure configuration
# Destination read structures can be defined by concatenating destination sequence segments using “+”.
READ1_STRUCTURE=dest_segment1+dest_segment2
READ2_STRUCTURE=dest_segment3

