[general]
# Working directory
PROJECT_DIR= process/Drop/rev/

# Path to the shellscript template.
# Lines used in all the shell scripts generated by INTERSTELLAR, 
# such as shebang and conda activate should be included.

SET_SHELL_ENV= ~/work/Interstellar_test/set_shell_env

# SAMPLESHEET specifies the correspondence between the FASTQ file prefixes
# and their samplename (tab-separated).
#
# Example:
# heart_10k_v3_S1_L001	10X
# heart_10k_v3_S1_L002	10X
# 
# This means it gives two FASTQ files from a single sample sequenced by two lanes

SAMPLESHEET = config/Drop/Drop_rev.samplesheet

[value_extraction]
# Path to input FASTQ files. FASTQ file names must include the fleprefixes indicated in SAMPLESHEET.
# 
# Example:
# READ1_PATH=/path/to/Input_dir/R1/*.fastq.gz
# READ2_PATH=/path/to/Input_dir/R2/*.fastq.gz
# 
# Alternatively, user can provide a directory path containing FASTQ files.
# READ1_PATH=/path/to/Input_dir/R1/
# READ2_PATH=/path/to/Input_dir/R2/

READ1_PATH= process/Drop/fwd/Drop/value_translation/out/translated_R1.fastq.gz
READ2_PATH= process/Drop/fwd/Drop/value_translation/out/translated_R2.fastq.gz

# Read structures specified by regular expression.
# Variables specified by ?P<> are user-defined sequence segments. INTERSTELLAR adopts the extended 
# regular expression implemented in the regex library (https://pypi.org/project/regex/) that allows mismatches.

READ1_STRUCTURE=^(?P<raw_cb>.{11})(?P<raw_umi>.{7})$
READ2_STRUCTURE=^(?P<raw_bio>.*)$

# Parental-local variable allocations.
# Under this allocation, sequence-to-value conversion of the local segment(s) is independently performed for its parental segment. 
# For example, cell IDs and UMIs of typical scRNA-seq reads can be defined as parental segments and their local segments, respectively,
# where the same UMI sequences associated with different cell IDs are interpreted as different objects. 
#
# Ex. 1) seg1 is a local variable of seg2:
# seg1 = CHILD_OF(seg2)
# 
# Ex. 2) seg2 and seg3 together consist of a combinatorial variable where seg1 is local to them:
# seg1 = CHILD_OF(seg2,seg3)
#
# Ex. 3) a combinatorial variable (seg1, seg2) is local to another combinatorial variable (seg3, seg4):
# seg1,seg2 = CHILD_OF(seg3,seg4)

raw_umi=CHILD_OF(raw_cb)

cb.val = SEQ2VALUE(source:raw_cb)
umi.val = SEQ2VALUE(source:raw_umi)


[value_translation]
# Defining destination segment sequences
# The destination sequence segments can be defined by VALUE2SEQ() or SEQ2SEQ(), or by directly assigning source sequence segments.
# The following functions can be used for producing defining sequence segments.
#
# - VALUE2SEQ()
#   Assign destination segment sequences to values so they fit to an allowlist or destination sequence segment structure. 
#   In this section, value space optimization is automatically performed for source segment values according to the segment grouping rules and 
#   parental-local segment value allocations defined in the value_extraction section. 
#   The value space optimization is not performed if any parental-local segment value allocation is defined earlier.
#
#   * source (required)
#     Value names. Comma-separated values if multiple values are translated into a sequence segment. Note that the source segment combinations used in
#
#   * allowlist_path
#     Path to the destination sequence allowlist. If multiple destination sequence segments are to be generated, provide their corresponding allowlists 
#     as comma-separated values in the same order of destination sequence segments.
#
#   * randseq_pattern
#     Destination sequence segment structure defined by IUPAC codes. If multiple destination sequence segments are to be defined, provide their corresponding 
#     allowlists as comma-separated values in the same order of destination sequence segments.
#
# - SEQ2SEQ() 
#   Assign destination segment sequences defined for their corresponding source segment sequences according to a user-defined sequence conversion table.
#
#   * source (required):
#     Source sequence segment name. Comma-separated values if multiple source segments are converted into a destination sequence(s).
#
#   * conversion_table
#     Path to the sequence conversion table (TSV file format). The header line must correspond to the target source and destination sequence segment names 
#     defined in the configuration file. Each SEQ2SEQ function requires a unique sequence conversion table.
#
# Bequeathing a source segment Source sequence segment variables can be used to define destination reads.

ex_umi =VALUE2SEQ(source:umi.val, randseq_pattern:NNNNNNNN)
ex_cb  =VALUE2SEQ(source:cb.val, randseq_pattern:NNNNNNNNNNNN)

# Read structure configuration
# Destination read structures can be defined by concatenating destination sequence segments using “+”.

READ1_STRUCTURE =ex_cb+ex_umi
READ2_STRUCTURE =raw_bio
